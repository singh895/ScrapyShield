% abstract.tex
% \begin{abstract}
% Automated web crawlers such as Scrapy are indispensable for search engines, market research, and data mining, yet their resilience to hostile inputs—like SQL Injection, Cross‐Site Scripting (XSS), and drive‐by malware downloads—has received little scrutiny. In this work, we simulate these attacks in a sandboxed Flask environment, hosting deliberately vulnerable endpoints, and drive customized Scrapy spiders against them. By measuring how Scrapy handles crafted SQLi payloads, reflected XSS scripts (with a headless browser shim), and executable file downloads, we expose blind spots in its default pipeline. Our results show that Scrapy neither sanitizes malicious form submissions nor blocks inline event handlers when rendering JavaScript, and indiscriminately retrieves malicious binaries. We conclude by proposing lightweight security middleware and sandboxing strategies that can harden Scrapy for use in adversarial web ecosystems.
    % \end{abstract}
Web crawlers like Scrapy are widely used to automate data collection from the internet. However, their resilience to web-based attacks such as SQL Injection (SQLi), Cross-Site Scripting (XSS), and Malware Downloads remains understudied. This project simulates these attack vectors within a controlled sandbox environment to evaluate Scrapy's security posture. We developed a malicious Flask web server hosting vulnerable endpoints and used a customized Scrapy crawler to interact with them. Our results show that Scrapy fails to adequately handle some adversarial inputs, particularly in SQL Injection and drive-by download scenarios. Based on our findings, we propose enhancements to improve Scrapy’s security mechanisms and contribute a reusable framework for crawler vulnerability testing.